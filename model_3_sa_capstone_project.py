# -*- coding: utf-8 -*-
"""Model-3 SA Capstone Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CMHsonwIYsuzC9FbgEyTAEYXUwyth3i7

# Set Up
Installing required libraries and dependencies
"""

!pip install pathway bokeh --quiet

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
from datetime import datetime
import pathway as pw
import bokeh.plotting
import panel as pn

"""# Step 1: Importing and Preprocessing the Data"""

df = pd.read_csv('/content/Modified - modified.csv')
df

df.drop("Unnamed: 0", axis=1, inplace=True)

# Combine the 'LastUpdatedDate' and 'LastUpdatedTime' columns into a single datetime column
df['Timestamp'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'],
                                  format='%d-%m-%Y %H:%M:%S')

df.drop(['LastUpdatedDate', 'LastUpdatedTime'], axis=1, inplace=True)

# Sort the DataFrame by the new 'Timestamp' column and reset the index
df = df.sort_values('Timestamp').reset_index(drop=True)

df

def vtype(val):
  if (val == 'cycle'):
    return 1
  elif (val == 'bike'):
    return 3
  elif (val == 'car'):
    return 5
  elif (val == 'truck'):
    return 7

df['VehicleType'] = df['VehicleType'].apply(vtype)

def cong(val):
  if (val == 'low'):
    return 1
  elif (val == 'average'):
    return 5
  elif (val == 'high'):
    return 9

df['TrafficConditionNearby'] = df['TrafficConditionNearby'].apply(cong)

def flt(val):
  if (val == 1):
    return 1
  elif (val == 0):
    return 0

df['IsSpecialDay'] = df['IsSpecialDay'].apply(flt)

df

"""# Model-3 (Competitive Pricing Model)

## Step - 1 (Preparation)
"""

class ParkingSchema3(pw.Schema):
    Timestamp: str   # Timestamp of the observation (should ideally be in ISO format)
    Occupancy: int   # Number of occupied parking spots
    Capacity: int    # Total parking capacity at the location
    IsSpecialDay: float  # Special Day indication: holiday or other special event
    VehicleType: int  # The type of vehicle: car, truck, bike
    TrafficConditionNearby: int  # Nearby traffic congestion level
    QueueLength: int  # Vehicles waiting for entry
    Latitude: float   # latitude of parking lot
    Longitude: float  # longitude of parking lot

# Model-3 Competitive Pricing Model
# Save the selected columns to a CSV file for streaming or downstream processing
df[["Timestamp", "Occupancy", "Capacity", "IsSpecialDay", "VehicleType", "TrafficConditionNearby", "QueueLength", "Latitude", "Longitude" ]].to_csv("parking_stream.csv", index=False)
data = pw.demo.replay_csv("parking_stream.csv", schema=ParkingSchema3, input_rate=1000)

# Define the datetime format to parse the 'Timestamp' column
fmt = "%Y-%m-%d %H:%M:%S"

# Add new columns to the data stream:
# - 't' contains the parsed full datetime
# - 'day' extracts the date part and resets the time to midnight (useful for day-level aggregations)
data_with_time = data.with_columns(
    t = data.Timestamp.dt.strptime(fmt),
    day = data.Timestamp.dt.strptime(fmt).dt.strftime("%Y-%m-%dT00:00:00")
)

"""## Step - 2 (Competitive Pricing Model)"""

# Constants
W_OCC = 3.0
W_QUEUE = 1.5
W_TRAFFIC = 1.0
W_DIST = 2.0

# Example
USER_LAT = 28.6139
USER_LON = 77.2090

@pw.udf
def haversine(lat1, lon1, lat2, lon2):
    from math import radians, sin, cos, sqrt, atan2
    R = 6371
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat/2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2)**2
    return R * 2 * atan2(sqrt(a), sqrt(1 - a))

@pw.udf
def compute_score(availability, queue, traffic, distance):
    return round(W_OCC * availability - W_QUEUE * queue - W_TRAFFIC * traffic - W_DIST * distance, 2)

data_with_time = data_with_time.with_columns(
    Distance = (
        haversine(USER_LAT, USER_LON, pw.this.Latitude, pw.this.Longitude)
        )
)

data_with_time = data_with_time.with_columns(
    Score = (
        compute_score(1 - (pw.this.Occupancy / pw.this.Capacity), pw.this.QueueLength, pw.this.TrafficConditionNearby, pw.this.Distance)
        )
)

data_with_time = data_with_time.with_columns(
    Coords = (pw.this.Latitude, pw.this.Longitude)  # ðŸ‘ˆ Combine as single field
)

#  Select Best Lot Per t
recommendation = data_with_time.groupby(data_with_time.t).reduce(
    Timestamp = pw.reducers.latest(data_with_time.t),
    RecommendedLot = pw.reducers.argmax(data_with_time.Score, data_with_time.Coords),
    Score = pw.reducers.max(data_with_time.Score)
)

"""## Step - 3 (Visualizing)"""

# Activate the Panel extension to enable interactive visualizations
pn.extension()

# Define a custom Bokeh plotting function that takes a data source (from Pathway) and returns a figure
def price_plotter(source):
    # Create a Bokeh figure with datetime x-axis
    fig = bokeh.plotting.figure(
        height=400,
        width=800,
        title="Pathway: Competitive Pricing Model (Model 3)",
        x_axis_type="datetime",  # Ensure time-based data is properly formatted on the x-axis
    )
    # Plot a line graph showing how the FinalPrice evolves over time
    fig.line("Timestamp", "Score", source=source, line_width=2, color="navy")

    # Overlay red circles at each data point for better visibility
    fig.scatter("Timestamp", "Score", source=source, size=6, color="red")

    return fig

# Use Pathway's built-in .plot() method to bind the data stream (data_with_demand) to the Bokeh plot
# - 'price_plotter' is the rendering function
# - 'sorting_col="Timestamp"' ensures the data is plotted in time order
viz = recommendation.plot(price_plotter, sorting_col="Timestamp")

# Create a Panel layout and make it servable as a web app
# This line enables the interactive plot to be displayed when the app is served
pn.Column(viz).servable()

"""# Run"""

# Commented out IPython magic to ensure Python compatibility.
# # Start the Pathway pipeline execution in the background
# # - This triggers the real-time data stream processing defined above
# # - %%capture --no-display suppresses output in the notebook interface
# 
# %%capture --no-display
# pw.run()

