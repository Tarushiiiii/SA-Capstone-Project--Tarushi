# -*- coding: utf-8 -*-
"""Model-2 SA Capstone Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C8gaRwEvDnU6pEF2ojFJBGom37oHDBUl

# Set Up
Installing required libraries and dependencies
"""

!pip install pathway bokeh --quiet

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
from datetime import datetime
import pathway as pw
import bokeh.plotting
import panel as pn

"""# Step 1: Importing and Preprocessing the Data"""

df = pd.read_csv('/content/Modified - modified.csv')
df

df.drop("Unnamed: 0", axis=1, inplace=True)

# Combine the 'LastUpdatedDate' and 'LastUpdatedTime' columns into a single datetime column
df['Timestamp'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'],
                                  format='%d-%m-%Y %H:%M:%S')

df.drop(['LastUpdatedDate', 'LastUpdatedTime'], axis=1, inplace=True)

# Sort the DataFrame by the new 'Timestamp' column and reset the index
df = df.sort_values('Timestamp').reset_index(drop=True)

df

df['VehicleType'].unique()

def vtype(val):
  if (val == 'cycle'):
    return 1
  elif (val == 'bike'):
    return 3
  elif (val == 'car'):
    return 5
  elif (val == 'truck'):
    return 7

df['VehicleType'] = df['VehicleType'].apply(vtype)

def cong(val):
  if (val == 'low'):
    return 1
  elif (val == 'average'):
    return 5
  elif (val == 'high'):
    return 9

df['TrafficConditionNearby'] = df['TrafficConditionNearby'].apply(cong)

def flt(val):
  if (val == 1):
    return 1
  elif (val == 0):
    return 0

df['IsSpecialDay'] = df['IsSpecialDay'].apply(flt)

df

"""# Model-2 (Demand-Based Price Function)

## Step - 1 (Preparation)
"""

class ParkingSchema2(pw.Schema):
    Timestamp: str   # Timestamp of the observation (should ideally be in ISO format)
    Occupancy: int   # Number of occupied parking spots
    Capacity: int    # Total parking capacity at the location
    IsSpecialDay: float  # Special Day indication: holiday or other special event
    VehicleType: int  # The type of vehicle: car, truck, bike
    TrafficConditionNearby: int  # Nearby traffic congestion level
    QueueLength: int  # Vehicles waiting for entry

# Model-2 Demand-Based Price Function
# Save the selected columns to a CSV file for streaming or downstream processing
df2 = df[["Timestamp", "Occupancy", "Capacity", "IsSpecialDay", "VehicleType", "TrafficConditionNearby", "QueueLength" ]].to_csv("parking_stream.csv", index=False)
data = pw.demo.replay_csv("parking_stream.csv", schema=ParkingSchema2, input_rate=1000)

# Define the datetime format to parse the 'Timestamp' column
fmt = "%Y-%m-%d %H:%M:%S"

# Add new columns to the data stream:
# - 't' contains the parsed full datetime
# - 'day' extracts the date part and resets the time to midnight (useful for day-level aggregations)
data_with_time = data.with_columns(
    t = data.Timestamp.dt.strptime(fmt),
    day = data.Timestamp.dt.strptime(fmt).dt.strftime("%Y-%m-%dT00:00:00")
)

"""## Step - 2 (Demand-Based Price Function)"""

BASE_PRICE = 10
ALPHA = 5
BETA = 0.8
GAMMA = 0.6
DELTA = 2.0
EPSILON = 1.2
LAMBDA = 0.5  # Scaling factor for normalized demand

# demand function
data_with_demand = data_with_time.with_columns(
    Demand = (
        ALPHA * (data_with_time.Occupancy / data_with_time.Capacity) +
        BETA * data_with_time.QueueLength -
        GAMMA * data_with_time.TrafficConditionNearby +
        DELTA * (data_with_time.IsSpecialDay) +
        EPSILON * pw.this.VehicleType
    )
)

@pw.udf
def normalize_demand(raw_demand: float) -> float:
    return min(max((raw_demand / 20), 0), 1)  # clipped to [0, 1]

data_with_demand = data_with_demand.with_columns(
    NormalizedDemand = normalize_demand(data_with_demand.Demand)
)

data_with_demand = data_with_demand.with_columns(
    Price = pw.this.NormalizedDemand * LAMBDA * BASE_PRICE + BASE_PRICE
)

# Bound price between 0.5x and 2x base price
@pw.udf
def clamp_price(price: float) -> float:
    return round(min(max(price, BASE_PRICE * 0.5), BASE_PRICE * 2.0), 2)

data_with_demand = data_with_demand.with_columns(
    FinalPrice = clamp_price(data_with_demand.Price)
)

"""## Step - 3 (Visualizaing)"""

# Activate the Panel extension to enable interactive visualizations
pn.extension()

# Define a custom Bokeh plotting function that takes a data source (from Pathway) and returns a figure
def price_plotter(source):
    # Create a Bokeh figure with datetime x-axis
    fig = bokeh.plotting.figure(
        height=400,
        width=800,
        title="Pathway: Demand Based Pricing (Model 2)",
        x_axis_type="datetime",  # Ensure time-based data is properly formatted on the x-axis
    )
    # Plot a line graph showing how the FinalPrice evolves over time
    fig.line("t", "FinalPrice", source=source, line_width=2, color="navy")

    # Overlay red circles at each data point for better visibility
    fig.scatter("t", "FinalPrice", source=source, size=6, color="red")

    return fig

# Use Pathway's built-in .plot() method to bind the data stream (data_with_demand) to the Bokeh plot
# - 'price_plotter' is the rendering function
# - 'sorting_col="t"' ensures the data is plotted in time order
viz = data_with_demand.plot(price_plotter, sorting_col="t")

# Create a Panel layout and make it servable as a web app
# This line enables the interactive plot to be displayed when the app is served
pn.Column(viz).servable()

"""# Run"""

# Commented out IPython magic to ensure Python compatibility.
# # Start the Pathway pipeline execution in the background
# # - This triggers the real-time data stream processing defined above
# # - %%capture --no-display suppresses output in the notebook interface
# 
# %%capture --no-display
# pw.run()

